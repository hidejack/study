<!DOCTYPE html>
<html>
<head>
<title>day01</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>JDBC</h1>
<h2>JDBC 是什么</h2>
<p>JDBC是Java应用程序和数据库之间的通信桥梁, 是Java应用程序访问数据库的通道.</p>
<ol>
<li>JDBC标准主要有一组接口组成, 其好处是统一了各种数据库访问方式.</li>
<li>JDBC接口的实现类称为数据库驱动,有各个数据库厂商提供. 使用JDBC必须导入这个驱动!</li>
</ol>
<blockquote>
<p>一定要知道驱动是什么!!</p>
</blockquote>
<h2>使用JDBC</h2>
<p>JDBC使用步骤:</p>
<ol>
<li>
导入JDBC驱动jar
<ul>
<li>使用Maven可以便捷的导入数据库驱动.</li>
</ul>
</li>
<li>
注册JDBC驱动
<ul>
<li>参数: &quot;驱动程序类名&quot;</li>
<li>Class.forName(&quot;驱动程序类名&quot;)</li>
</ul>
</li>
<li>
获得Connection对象
<ul>
<li>需要3个参数: url, username, password</li>
<li>连接到数据库</li>
</ul>
</li>
<li>
创建Statement(语句)对象
<ul>
<li>conn.createStatement() 方法创建对象</li>
<li>用于执行 SQL 语句</li>
<li>execute(ddl) 执行任何SQL, 常用执行DDL,DCL</li>
<li>executeUpdate(dml) 执行DML语句,如: insert update delete</li>
<li>executeQuery(dql) 执行DQL语句, 如: select</li>
</ul>
</li>
<li>
处理SQL执行结果:
<ul>
<li>execute(ddl) 如果没有异常则成功.</li>
<li>executeUpdate(dml) 返回数字,表示更新&quot;行&quot;数量,抛出异常则失败</li>
<li>executeQuery(dql) 返回ResultSet(结果集)对象, 代表2维查询结果, 使用for遍历处理, 如果查询失败抛出异常!</li>
</ul>
</li>
<li>
关闭数据连接!关闭数据连接!关闭数据连接!
<ul>
<li>conn.close(); </li>
</ul>
</li>
</ol>
<p>案例:</p>
<pre><code>public class Demo01 {
    public static void main(String[] args)
        throws Exception{
        Class.forName(&quot;oracle.jdbc.OracleDriver&quot;);
        //System.out.println(&quot;OK!&quot;);
        //链接到数据库
        String url=&quot;jdbc:oracle:thin:@192.168.201.227:1521:orcl&quot;;
        String username=&quot;openlab&quot;;
        String password=&quot;open123&quot;;
        //getConnection() 方法查找并且尝试
        //链接到数据库, 如果不成功将出现异常
        Connection conn=DriverManager
            .getConnection(
            url, username, password);
        //输出conn引用对象的实际类型
        //证明: 驱动程序提供了Connection接口的实现类
        System.out.println(conn.getClass());
        //创建 &quot;Statement语句&quot; 对象
        Statement st=conn.createStatement();
        //执行SQL(DDL)
        String ddl=&quot;create table robin_demo&quot;
                + &quot;( id number(7),&quot;
                + &quot;name varchar2(100))&quot;;
        boolean b=st.execute(ddl);
        //返回结果: true 表示有结果集
        //          false 没有结果集
        //          创建失败抛出异常
        //如何判断结果:如果没有异常,则创建成功!!
        System.out.println(b); 
        conn.close();
    }
}
</code></pre>

<p>执行 DML 语句 案例:</p>
<pre><code>/*
 * 执行DML语句
 */
public class Demo02 {
    public static void main(String[] args) 
        throws Exception {
        // 注册驱动
        Class.forName(&quot;oracle.jdbc.OracleDriver&quot;);
        //连接到数据库
        String url=&quot;jdbc:oracle:thin:@192.168.201.227:1521:orcl&quot;;
        String username=&quot;openlab&quot;;
        String password=&quot;open123&quot;;
        Connection conn=DriverManager.getConnection(
                url, username, password);
        //创建 Statement
        Statement st=conn.createStatement();
        //执行DML, 使用executeUpdate方法
        //String dml=&quot;insert into robin_demo&quot;
        //      + &quot;(id, name) &quot;
        //      + &quot;values (1,'Tom')&quot;;
        //String dml=&quot;update robin_demo &quot;
        //      + &quot;set name='Jerry' &quot;
        //      + &quot;where id=1 &quot;;
        String dml = &quot;delete from robin_demo &quot;
                + &quot;where id=1&quot;;
        int n=st.executeUpdate(dml);
        System.out.println(n); 
        //关闭连接!!
        conn.close();
        //select * from robin_demo
    }
}
</code></pre>

<h2>处理结果集ResultSet</h2>
<p>ResultSet代表DQL查询结果,是2维结果. 其内部维护了一个读取数据的游标,默认情况在,游标在第一行数据之前, 当调用next() 方法时候, 游标会向下移动,并将返回结果集中是否包含数据, 如果包含数据就返回true. 结果集还提供了很好getXXX方法用于获取结果集游标指向当前行数据.</p>
<p>原理:</p>
<p><img src="1.png" /></p>
<p>案例:</p>
<pre><code>/**
 * 执行DQL 语句 
 */
public class Demo03 {
    public static void main(String[] args) 
        throws Exception{
        //注册驱动
        String driver=&quot;oracle.jdbc.OracleDriver&quot;;;
        Class.forName(driver);
        //连接数据库
        String url=&quot;jdbc:oracle:thin:@192.168.201.227:1521:orcl&quot;;
        String user=&quot;openlab&quot;;
        String pwd=&quot;open123&quot;;
        Connection conn=DriverManager.getConnection(
                url, user, pwd);
        //创建Statement
        Statement st=conn.createStatement();
        //执行SQL(dql)
        String sql=&quot;select id, name &quot;
                + &quot;from robin_demo &quot;;
        ResultSet rs=st.executeQuery(sql);
        //处理结果 ...
        //rs结果集中包含一个游标,游标默认在结果集
        //的第一行之前
        //rs.next():移动结果集游标到下一行
        //检查是否有数据, 如果有返回true, 否则false
        while(rs.next()){
            //getXXX(列名): 返回结果集当前行中
            // 指定列名的数据.
            int id = rs.getInt(&quot;id&quot;);
            String name=rs.getString(&quot;name&quot;);
            //输出查询结果
            System.out.println(id+&quot;,&quot;+name);
        }
        //关闭连接
        conn.close();
    }
}
</code></pre>

<h2>使用Properties 读取配置文件</h2>
<p>Properties 是Java中专门用于读取配置文件的API. </p>
<ol>
<li>其底层就是文本文件IO</li>
<li>Properties 本身 实现 Map接口, 内部是散列表</li>
<li>Properties限定了key和Value都是String 类型.</li>
</ol>
<p>Properties 常用API方法:</p>
<ul>
<li>load(流) 读取一个配置文件</li>
<li>String getProperty(key) 读取一个属性值</li>
</ul>
<p>使用步骤:</p>
<ol>
<li>创建Properties对象</li>
<li>利用load方法读取配置文件</li>
<li>利用getProperty查询属性文件的内容</li>
</ol>
<p>案例, 读取配置文件:</p>
<p>在resource 文件夹中添加配置文件 db.properties:</p>
<pre><code># db.properties
jdbc.driver=oracle.jdbc.OracleDriver
jdbc.url=jdbc:oracle:thin:@192.168.201.227:1521:orcl
jdbc.username=openlab
jdbc.password=open123
</code></pre>

<p>使用Properties读取配置文件内容:</p>
<pre><code>public class Demo05 {
    public static void main(String[] args)
        throws IOException{
        // Properties 就是为了读取
        // *.properties 文件而设计的API
        // 其底层就是文本文件IO
        // Properties 本身 实现 Map接口
        // 内部是散列表, 限定了key和Value都是
        // String 类型.

        //方法: load(流) 将文件就读取为散列表
        //String getProperty(key) 查询value

        //使用步骤
        //1 创建 Properties 对象
        Properties cfg = new Properties();
        System.out.println(cfg);
        System.out.println(cfg.size());
        System.out.println(cfg.isEmpty());
        //2. 利用load方法读取文件
        InputStream in=
            Demo05.class.getClassLoader()
            .getResourceAsStream(&quot;db.properties&quot;);
        //执行以后,将文件内容读取到散列表中了
        cfg.load(in); 
        System.out.println(cfg);
        System.out.println(cfg.size());

        //3. 查找文件内容, 就是读取文件内容
        String s=
            cfg.getProperty(&quot;jdbc.driver&quot;);
        System.out.println(s); 
    }
}
</code></pre>

<blockquote>
<p>利用配置文件可以将程序中的参数保存到配置文件中, 修改程序参数只需要修改配置文件即可.</p>
</blockquote>
<h2>管理数据库连接</h2>
<p>在软件中数据库连接使用非常频繁, 如果每次都创建连接, 就会造成代码的大量冗余, 常规的做法是建立数据库连接工具类, 封装数据库连接过程, 统一数据库连接过程, 使用时候就可以简化代码.</p>
<p>实现步骤:</p>
<ol>
<li>创建数据库连接参数文件 db.properties</li>
<li>
创建DbUtils.java 封装数据库连接方法
<ul>
<li>利用Properties读取配置文件夹中的数据库连接参数</li>
<li>创建方法 getConnection 封装数据库连接过程</li>
</ul>
</li>
<li>使用 getConnection 方法</li>
</ol>
<h3>创建配置文件  db.properties</h3>
<pre><code># db.properties
jdbc.driver=oracle.jdbc.OracleDriver
jdbc.url=jdbc:oracle:thin:@192.168.201.227:1521:orcl
jdbc.username=openlab
jdbc.password=open123
</code></pre>

<h3>创建DbUtils.java</h3>
<pre><code>public class DbUtils {
    static String driver;
    static String url;
    static String username;
    static String password;

    //读取文件中的数据库连接参数
    static{
        //初始化静态属性
        //1. 利用Properties 读取配置文件
        //2. 从配置文件中查找 相应参数值
        try{
            Properties cfg=new Properties();
            InputStream in=
                DbUtils.class.getClassLoader()
                .getResourceAsStream(&quot;db.properties&quot;);
            cfg.load(in);
            System.out.println(cfg); 
            //初始化 连接参数 
            driver=cfg.getProperty(&quot;jdbc.driver&quot;);
            url=cfg.getProperty(&quot;jdbc.url&quot;);
            username=cfg.getProperty(&quot;jdbc.username&quot;);
            password=cfg.getProperty(&quot;jdbc.password&quot;);
            in.close();
        }catch(Exception e){
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    /**
     * 封装创建数据库连接的过程
     * 简化数据库连接
     */
    public static Connection getConnection(){
        try{
            Class.forName(driver);
            Connection conn=
                DriverManager.getConnection(
                url, username, password);
            return conn;
        }catch(Exception e){
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    //DbUtils.java
    /*
     * 关闭数据库的连接方法, 封装复杂的关闭过程
     */
    public static void close(Connection conn){
        if(conn!=null){
            try {
                conn.close();
            } catch (Exception e) {
                e.printStackTrace(); 
            }
        }
    }
}
</code></pre>

<p>说明:</p>
<ol>
<li>driver url username password 是4个数据库连接参数, 因为只需要一份,则定义为静态变量.</li>
<li>静态代码块的目的是从配置文件中读取4个数据库连接参数的值.</li>
<li>getConnection方法封装了数据库连接过程</li>
<li>close方法封装了数据库连接关闭的过程</li>
</ol>
<h3>DbUtils 的使用:</h3>
<pre><code>public class Demo06 {
    public static void main(String[] args) {
        Connection conn=null;
        try{
            conn=DbUtils.getConnection();
            Statement st=conn.createStatement();
            String sql=&quot;select * from robin_demo&quot;;
            ResultSet rs=st.executeQuery(sql);
            while(rs.next()){
                int id=rs.getInt(&quot;id&quot;);
                String name=rs.getString(&quot;name&quot;);
                System.out.println(id+&quot;,&quot;+name);
            }
            rs.close();//释放查询结果
            st.close();//释放语句对象
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            DbUtils.close(conn);
        }
    }
}
</code></pre>

<blockquote>
<p>显然: 使用DbUtils可以简化JDBC代码的书写. 
这个代码中在finally中关闭数据库连接, 其好处是可靠关闭连接.</p>
</blockquote>
<hr />
<h2>作业:</h2>
<ol>
<li>创建新的Maven项目导入Oracle数据库驱动</li>
<li>独立编写数据库连接管理工具类 DbUtils</li>
<li>利用DbUtils实现员工表的 插入操作</li>
<li>利用DbUtils实现员工表的 修改操作</li>
<li>利用DbUtils实现员工表的 删除操作</li>
<li>利用DbUtils实现员工表的 查询操作</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
