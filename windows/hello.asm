    .386                    ;伪指令，告诉编译器当前使用386指令集
;    .386p                  带p表明程序中可以使用特权指令
;   .mmx                    表明需要使用MMX指令

;   定义程序工作的模式： .model 内存模式 [，语言模式][.其他模式]
;   stdcall 指出了调用子程序或Win32 API时参数传递的次序和堆栈平衡的方法。
;   Windows API 调用使用的是stdcall格式，Win32汇编中没得选择
;   内存段定义如下
;   tiny:用来建立.com 文件，所有的代码、数据和堆栈都在同一个64KB段内
;   small：建立代码和数据分别用一个64KB段的 .exe 文件
;   medium：代码段可以有多个64KB段，数据段只有一个64KB段
;   compact：代码段只有一个64KB段，数据段可以有多个64KB段
;   large：代码段和数据段都可以有多个64KB段
;   huge:同large，并且数据段中的一个数组也可以超过64KB
;   flat ：Win32程序使用的模式，代码和数据段使用同一个4GB段
    .model  flat,stdcall
;   .model 定义后各段寄存器如下定义（平坦模式）：
;   ASSUME  cs:FLAT, ds:FLAT,ss:FLAT,es:FLAT,fs:ERROR,gs:ERROR

;   用option定义的选项很多：option language/segment 等
;   Win32汇编中，需要的只是定义如下。含义为：
;   定义了程序中的变量和子程序名是否对大小写敏感。Win32 API 区分大小写，所以这里必须指定
    option  casemap:none

;-----------------------------------------------------------
;   Include 文件定义
;-----------------------------------------------------------
include         windows.inc
include         user32.inc
includelib      user32.lib
include         kernel32.inc
includelib      kernel32.lib
;-----------------------------------------------------------
;数据段
;.stack/.data/.data?/.const/.code 都是分段伪指令
;win32 中实际只有代码和数据之分。.data/.data?/.const 都是数据段 .code 是代码段
; win32汇编不用考虑堆栈，系统会为程序分配一个向下扩展的、足够大的作为堆栈段。，stack常被忽略。
;不同的数据定义，生成的可执行文件存放的节区不同。
;一共可分为3类数据定义
;1 .data:可读可写的已定义变量。源程序中定义了初始值，可读可写。存放在可执行文件的_DATA节区中。
;2 .data/.data?:可读可写的未定义变量。一般当作缓冲区或者在程序执行后才开始使用。 一般放在.data? 中。
;  虽然在.data 中也可以定义。但是定义在.data? 段中不会增大.exe 文件的大小。.data? 可变长度数据空间。在可执行文件中一般存放在_BSS 节区中
;3 .const : 常量，可读不可写。
;-----------------------------------------------------------
            .data
szCaption       db      'A MessageBox !',0
szText          db      'Hello,World !'.0
;-----------------------------------------------------------
;代码段（一般在可执行文件的_TEXT 节区中）
;对于特权级3的应用程序，.code 是不可写的。
;优先级3下运行的程序不是一定不能写代码段。代码段的属性由可执行文件PE头部中的属性位决定的。
;通过编辑.exe文件，把代码段属性位改成可写，那么在程序中就允许修改自己的代码段。
;典型的应用是一些针对可执行文件的压缩软件和加壳软件。这些软件靠把代码段进行变换来达到解压缩或解密的目的。
;被处理过的可执行文件在执行时需要由解压代码来将代码段解压缩，这就需要写代码段。
;所以这些软件对可执行文件代码段的属性预先做了修改
;-----------------------------------------------------------
            .code
start:
            invoke  MessageBox,NULL,offset szText,\     ;\ 换行符
                    offset szCaption,MB_OK
            invoke  ExitProcess,NULL

end start

;-----------------------------------------------------------
;堆栈段
;不必定义堆栈段，系统会自动分配堆栈空间。
;堆栈段的内存属性是可读写并且是可执行的。
;因此，动态修改代码的反跟踪模块可以拷贝到堆栈中边修改边执行。
;黑客工具or病毒用到的缓冲区溢出技术用到了这个特征
;-----------------------------------------------------------